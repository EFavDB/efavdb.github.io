<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>EFAVDB - Machine learning</title><link href="https://efavdb.com/" rel="alternate"></link><link href="https://efavdb.com/feeds/machine-learning.atom.xml" rel="self"></link><id>https://efavdb.com/</id><updated>2020-03-28T00:00:00-07:00</updated><subtitle>Everybody's Favorite Data Blog</subtitle><entry><title>Dynamic programming in reinforcement learning</title><link href="https://efavdb.com/reinforcement-learning-dynamic-programming" rel="alternate"></link><published>2020-03-28T00:00:00-07:00</published><updated>2020-03-28T00:00:00-07:00</updated><author><name>Cathy Yeh</name></author><id>tag:efavdb.com,2020-03-28:/reinforcement-learning-dynamic-programming</id><summary type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;We discuss how to use dynamic programming (&lt;span class="caps"&gt;DP&lt;/span&gt;) to solve reinforcement learning (&lt;span class="caps"&gt;RL&lt;/span&gt;) problems where we have a perfect model of the environment.  &lt;span class="caps"&gt;DP&lt;/span&gt; is a general approach to solving problems by breaking them into subproblems that can be solved separately, cached, then combined to solve the overall&amp;nbsp;problem …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;We discuss how to use dynamic programming (&lt;span class="caps"&gt;DP&lt;/span&gt;) to solve reinforcement learning (&lt;span class="caps"&gt;RL&lt;/span&gt;) problems where we have a perfect model of the environment.  &lt;span class="caps"&gt;DP&lt;/span&gt; is a general approach to solving problems by breaking them into subproblems that can be solved separately, cached, then combined to solve the overall&amp;nbsp;problem.&lt;/p&gt;
&lt;p&gt;We’ll use a toy model, taken from [1], of a student transitioning between five states in college, which we also used in our &lt;a href="https://efavdb.com/intro-rl-toy-example.html"&gt;introduction&lt;/a&gt; to &lt;span class="caps"&gt;RL&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP" src="https://efavdb.com/images/student_mdp.png"&gt;&lt;/p&gt;
&lt;p&gt;The model (dynamics) of the environment describe the probabilities of receiving a reward &lt;span class="math"&gt;\(r\)&lt;/span&gt; in the next state &lt;span class="math"&gt;\(s'\)&lt;/span&gt; given the current state &lt;span class="math"&gt;\(s\)&lt;/span&gt; and action &lt;span class="math"&gt;\(a\)&lt;/span&gt; taken, &lt;span class="math"&gt;\(p(s’, r | s, a)\)&lt;/span&gt;.  We can read these dynamics off the diagram of the student Markov Decision Process (&lt;span class="caps"&gt;MDP&lt;/span&gt;), for&amp;nbsp;example:&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(p(s'=\text{CLASS2}, r=-2 | s=\text{CLASS1}, a=\text{study}) =&amp;nbsp;1.0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(p(s'=\text{CLASS2}, r=1 | s=\text{CLASS3}, a=\text{pub}) =&amp;nbsp;0.4\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;d like to jump straight to code, see this &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP_dynamic_programming_solutions.ipynb"&gt;jupyter notebook&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;The role of value functions in &lt;span class="caps"&gt;RL&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;The agent’s (student’s) policy maps states to actions, &lt;span class="math"&gt;\(\pi(a|s) := p(a|s)\)&lt;/span&gt;. 
The goal is to find the optimal policy &lt;span class="math"&gt;\(\pi_*\)&lt;/span&gt; that will maximize the expected cumulative rewards, the discounted return &lt;span class="math"&gt;\(G_t\)&lt;/span&gt;, in each state &lt;span class="math"&gt;\(s\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The value functions, &lt;span class="math"&gt;\(v_{\pi}(s)\)&lt;/span&gt; and &lt;span class="math"&gt;\(q_{\pi}(s, a)\)&lt;/span&gt;, in MDPs formalize this&amp;nbsp;goal.&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}
v_{\pi}(s) &amp;amp;=&amp;amp; \mathbb{E}_{\pi}[G_t | S_t = s] \\
q_{\pi}(s, a) &amp;amp;=&amp;amp; \mathbb{E}_{\pi}[G_t | S_t = s, A_t = a]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;We want to be able to calculate the value function for an arbitrary policy, i.e. &lt;em&gt;prediction&lt;/em&gt;, as well as use the value functions to find an optimal policy, i.e. the &lt;em&gt;control&lt;/em&gt;&amp;nbsp;problem.&lt;/p&gt;
&lt;h2&gt;Policy&amp;nbsp;evaluation&lt;/h2&gt;
&lt;p&gt;Policy evaluation deals with the problem of calculating the value function for some arbitrary policy.  In our introduction to &lt;span class="caps"&gt;RL&lt;/span&gt; &lt;a href="https://efavdb.com/intro-rl-toy-example.html"&gt;post&lt;/a&gt;, we showed that the value functions obey self-consistent, recursive relations, that make them amenable to &lt;span class="caps"&gt;DP&lt;/span&gt; approaches given a model of the&amp;nbsp;environment.&lt;/p&gt;
&lt;p&gt;These recursive relations are the Bellman expectation equations, which write the value of each state in terms of an average over the values of its successor / neighboring states, along with the expected reward along the&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;The Bellman expectation equation for &lt;span class="math"&gt;\(v_{\pi}(s)\)&lt;/span&gt;&amp;nbsp;is&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value-bellman} \tag{1}
v_{\pi}(s) = \sum_{a} \pi(a|s) \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_{\pi}(s’) ],
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt; is the discount factor &lt;span class="math"&gt;\(0 \leq \gamma \leq 1\)&lt;/span&gt; that weights the importance of future vs. current returns. &lt;strong&gt;&lt;span class="caps"&gt;DP&lt;/span&gt; turns (\ref{state-value-bellman}) into an update rule&lt;/strong&gt; (\ref{policy-evaluation}), &lt;span class="math"&gt;\(\{v_k(s’)\} \rightarrow v_{k+1}(s)\)&lt;/span&gt;, which iteratively converges towards the solution, &lt;span class="math"&gt;\(v_\pi(s)\)&lt;/span&gt;, for&amp;nbsp;(\ref{state-value-bellman}):&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{policy-evaluation} \tag{2}
v_{k+1}(s) = \sum_{a} \pi(a|s) \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_k(s’) ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;Applying policy evaluation to our student model for an agent with a random policy, we arrive at the following state value function (see &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP_dynamic_programming_solutions.ipynb"&gt;jupyter notebook&lt;/a&gt; for&amp;nbsp;implementation):&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP value function random policy" src="https://efavdb.com/images/student_mdp_values_random_policy.png"&gt;&lt;/p&gt;
&lt;h2&gt;Finding the optimal value functions and&amp;nbsp;policy&lt;/h2&gt;
&lt;h3&gt;Policy&amp;nbsp;iteration&lt;/h3&gt;
&lt;p&gt;We can evaluate the value functions for a given policy by turning the Bellman expectation equation (\ref{state-value-bellman}) into an update equation with the iterative policy evaluation&amp;nbsp;algorithm.&lt;/p&gt;
&lt;p&gt;But how do we use value functions to achieve our end goal of finding an optimal policy that corresponds to the optimal value&amp;nbsp;functions?&lt;/p&gt;
&lt;p&gt;Imagine we know the value function for a policy.  If taking the greedy action, corresponding to taking &lt;span class="math"&gt;\(\text{arg} \max_a q_{\pi}(s,a)\)&lt;/span&gt;, from any state in that policy is not consistent with that policy, or, equivalently, &lt;span class="math"&gt;\(\max_a q_{\pi}(s,a) &amp;gt; v_\pi(s)\)&lt;/span&gt;, then the policy is not optimal since we can improve the policy by taking the greedy action in that state and then onwards following the original&amp;nbsp;policy.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;policy iteration&lt;/em&gt; algorithm involves taking turns calculating the value function for a policy (policy evaluation) and improving on the policy (policy improvement) by taking the greedy action in each state for that value function until converging to &lt;span class="math"&gt;\(\pi_*\)&lt;/span&gt; and &lt;span class="math"&gt;\(v_*\)&lt;/span&gt; (see [2] for pseudocode for policy&amp;nbsp;iteration).&lt;/p&gt;
&lt;h3&gt;Value&amp;nbsp;iteration&lt;/h3&gt;
&lt;p&gt;Unlike policy iteration, the value iteration algorithm does not require complete convergence of policy evaluation before policy improvement, and, in fact, makes use of just a single iteration of policy evaluation.  Just as policy evaluation could be viewed as turning the Bellman expectation equation into an update, value iteration turns the Bellman optimality equation into an&amp;nbsp;update.&lt;/p&gt;
&lt;p&gt;In our previous &lt;a href="https://efavdb.com/intro-rl-toy-example.html"&gt;post&lt;/a&gt; introducing &lt;span class="caps"&gt;RL&lt;/span&gt; using the student example, we saw that the optimal value functions are the solutions to the Bellman optimality equation, e.g. for the optimal state-value&amp;nbsp;function:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value-bellman-optimality} \tag{3}
v_*(s) &amp;amp;=&amp;amp; \max_a q_{\pi*}(s, a) \\
    &amp;amp;=&amp;amp; \max_a \mathbb{E} [R_{t+1} + \gamma v_*(S_{t+1}) | S_t = s, A_t = a] \\
    &amp;amp;=&amp;amp; \max_a \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_*(s’) ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;As a &lt;span class="caps"&gt;DP&lt;/span&gt; update equation, (\ref{state-value-bellman-optimality})&amp;nbsp;becomes:
&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{value-iteration} \tag{4}
v_{k+1}(s) = \max_a \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_k(s’) ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;Value iteration combines (truncated) policy evaluation with policy improvement in a single step; the state-value functions are updated with the averages of the value functions of the neighbor states that can occur from a greedy action, i.e. the action that maximizes the right hand side of&amp;nbsp;(\ref{value-iteration}).&lt;/p&gt;
&lt;p&gt;Applying value iteration to our student model, we arrive at the following optimal state value function, with the optimal policy delineated by red arrows (see &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP_dynamic_programming_solutions.ipynb"&gt;jupyter notebook&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP optimal policy and value function" src="https://efavdb.com/images/student_mdp_optimal_policy.png"&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;We’ve discussed how to solve for (a) the value functions of an arbitrary policy, (b) the optimal value functions and optimal policy.  Solving for (a) involves turning the Bellman expectation equations into an update, whereas (b) involves turning the Bellman optimality equations into an update.  These algorithms are guaranteed to converge (see [1] for notes on how the contraction mapping theorem guarantees&amp;nbsp;convergence).&lt;/p&gt;
&lt;p&gt;You can see the application of both policy evaluation and value iteration to the student model problem in this &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP_dynamic_programming_solutions.ipynb"&gt;jupyter notebook&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="References"&gt;References&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;[1] David Silver&amp;#8217;s &lt;span class="caps"&gt;RL&lt;/span&gt; Course Lecture 3 - Planning by Dynamic Programming (&lt;a href="https://www.youtube.com/watch?v=Nd1-UUMVfz4"&gt;video&lt;/a&gt;,
  &lt;a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/DP.pdf"&gt;slides&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;[2] Sutton and Barto -
  &lt;a href="http://incompleteideas.net/book/RLbook2018.pdf"&gt;Reinforcement Learning: An Introduction&lt;/a&gt; - Chapter 4: Dynamic&amp;nbsp;Programming&lt;/p&gt;
&lt;p&gt;[3] Denny Britz’s &lt;a href="https://github.com/dennybritz/reinforcement-learning/tree/master/DP"&gt;notes&lt;/a&gt; on &lt;span class="caps"&gt;RL&lt;/span&gt; and &lt;span class="caps"&gt;DP&lt;/span&gt;, including crisp implementations in code of policy evaluation, policy iteration, and value iteration for the gridworld example discussed in&amp;nbsp;[2].&lt;/p&gt;
&lt;p&gt;[4] Deep &lt;span class="caps"&gt;RL&lt;/span&gt; Bootcamp Lecture 1: Motivation + Overview + Exact Solution Methods, by Pieter Abbeel (&lt;a href="https://www.youtube.com/watch?v=qaMdN6LS9rA"&gt;video&lt;/a&gt;, &lt;a href="https://drive.google.com/open?id=0BxXI_RttTZAhVXBlMUVkQ1BVVDQ"&gt;slides&lt;/a&gt;) - a very compressed&amp;nbsp;intro.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Machine learning"></category><category term="reinforcement learning"></category><category term="machine learning"></category></entry><entry><title>Introduction to reinforcement learning by example</title><link href="https://efavdb.com/intro-rl-toy-example" rel="alternate"></link><published>2020-03-11T00:00:00-07:00</published><updated>2020-03-11T00:00:00-07:00</updated><author><name>Cathy Yeh</name></author><id>tag:efavdb.com,2020-03-11:/intro-rl-toy-example</id><summary type="html">&lt;p&gt;We take a top-down approach to introducing reinforcement learning (&lt;span class="caps"&gt;RL&lt;/span&gt;) by starting with a toy example: a student going through college.  In order to frame the problem from the &lt;span class="caps"&gt;RL&lt;/span&gt; point-of-view, we&amp;#8217;ll walk through the following&amp;nbsp;steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Setting up a model of the problem&lt;/strong&gt; as a Markov Decision Process …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;We take a top-down approach to introducing reinforcement learning (&lt;span class="caps"&gt;RL&lt;/span&gt;) by starting with a toy example: a student going through college.  In order to frame the problem from the &lt;span class="caps"&gt;RL&lt;/span&gt; point-of-view, we&amp;#8217;ll walk through the following&amp;nbsp;steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Setting up a model of the problem&lt;/strong&gt; as a Markov Decision Process, the framework that underpins the &lt;span class="caps"&gt;RL&lt;/span&gt; approach to sequential decision-making&amp;nbsp;problems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deciding on an objective&lt;/strong&gt;: maximize&amp;nbsp;rewards&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Writing down an equation whose solution is our objective&lt;/strong&gt;: Bellman&amp;nbsp;equations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;David Silver walks through this example in his &lt;a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html"&gt;lecture notes&lt;/a&gt; on &lt;span class="caps"&gt;RL&lt;/span&gt;, but as far as we can tell, does not provide code, so we&amp;#8217;re sharing our implementation,&amp;nbsp;comprising:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the student&amp;#8217;s college &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/discrete_limit_env.py"&gt;environment&lt;/a&gt; using the OpenAI gym&amp;nbsp;package.&lt;/li&gt;
&lt;li&gt;a &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP.ipynb"&gt;jupyter notebook&lt;/a&gt; sampling from the&amp;nbsp;model&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Student in toy&amp;nbsp;college&lt;/h2&gt;
&lt;p&gt;We model the student as an agent in a college environment who can move between five states: &lt;span class="caps"&gt;CLASS&lt;/span&gt; 1, 2, 3, the &lt;span class="caps"&gt;FACEBOOK&lt;/span&gt; state, and &lt;span class="caps"&gt;SLEEP&lt;/span&gt; state.  The states are represented by the four circles and square.  The &lt;span class="caps"&gt;SLEEP&lt;/span&gt; state &amp;#8212; the square with no outward bound arrows &amp;#8212; is a terminal state, i.e. once a student reaches that state, her journey is&amp;nbsp;finished.&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP" src="https://efavdb.com/images/student_mdp.png"&gt;&lt;/p&gt;
&lt;p&gt;Actions that a student can take in her current state are labeled in red (facebook/quit/study/sleep/pub) and influence which state she’ll find herself in&amp;nbsp;next.&lt;/p&gt;
&lt;p&gt;In this model, most state transitions are deterministic functions of the action in the current state, e.g. if she decides to study in &lt;span class="caps"&gt;CLASS&lt;/span&gt; 1, then she’ll definitely advance to &lt;span class="caps"&gt;CLASS&lt;/span&gt; 2.  The single non-deterministic state transition is if she goes pubbing while in &lt;span class="caps"&gt;CLASS&lt;/span&gt; 3, where the pubbing action is indicated by a solid dot; she can end up in &lt;span class="caps"&gt;CLASS&lt;/span&gt; 1, 2 or back in 3 with probability 0.2, 0.4, or 0.4, respectively, depending on how reckless the pubbing&amp;nbsp;was.&lt;/p&gt;
&lt;p&gt;The model also specifies the reward &lt;span class="math"&gt;\(R\)&lt;/span&gt; associated with acting in one state and ending up in the next.  In this example, the dynamics &lt;span class="math"&gt;\(p(s’,r|s,a)\)&lt;/span&gt;, are given to us, i.e. we have a full model of the environment, and, hopefully, the rewards have been designed to capture the actual end goal of the&amp;nbsp;student.&lt;/p&gt;
&lt;h2&gt;Markov Decision&amp;nbsp;Process&lt;/h2&gt;
&lt;p&gt;Formally, we’ve modeled the student’s college experience as a finite Markov Decision Process (&lt;span class="caps"&gt;MDP&lt;/span&gt;).  The dynamics are Markov because the probability of ending up in the next state depends only on the current state and action, not on any history leading up to the current state.  The Markov property is integral to the simplification of the equations that describe the model, which we&amp;#8217;ll see in a&amp;nbsp;bit.&lt;/p&gt;
&lt;p&gt;The components of an &lt;span class="caps"&gt;MDP&lt;/span&gt;&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S\)&lt;/span&gt; - the set of possible&amp;nbsp;states&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(R\)&lt;/span&gt; - the set of (scalar)&amp;nbsp;rewards&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(A\)&lt;/span&gt; - the set of possible actions in each&amp;nbsp;state&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The dynamics of the system are described by the probabilities of receiving a reward in the next state given the current state and action taken, &lt;span class="math"&gt;\(p(s’,r|s,a)\)&lt;/span&gt;.  In this example, the &lt;span class="caps"&gt;MDP&lt;/span&gt; is finite because there are a finite number of states, rewards, and&amp;nbsp;actions.&lt;/p&gt;
&lt;p&gt;The student’s agency in this environment comes from how she decides to act in each state.  The mapping of a state to actions is the &lt;strong&gt;policy&lt;/strong&gt;, &lt;span class="math"&gt;\(\pi(a|s) := p(a|s)\)&lt;/span&gt;, and can be a deterministic or stochastic function of her&amp;nbsp;state.&lt;/p&gt;
&lt;p&gt;Suppose we have an indifferent student who always chooses actions randomly.  We can sample from the &lt;span class="caps"&gt;MDP&lt;/span&gt; to get some example trajectories the student might experience with this policy.  In the sample trajectories below, the states are enclosed in parentheses &lt;code&gt;(STATE)&lt;/code&gt;, and actions enclosed in square brackets &lt;code&gt;[action]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sample trajectories&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLASS1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[quit]--&amp;gt;(CLASS1)--[facebook]--&amp;gt;(FACEBOOK)--[quit]--&amp;gt;(CLASS1)--[study]--&amp;gt;(CLASS2)--[sleep]--&amp;gt;(SLEEP)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FACEBOOK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;--[quit]--&amp;gt;(CLASS1)--[study]--&amp;gt;(CLASS2)--[study]--&amp;gt;(CLASS3)--[study]--&amp;gt;(SLEEP)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SLEEP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLASS1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;--[facebook]--&amp;gt;(FACEBOOK)--[quit]--&amp;gt;(CLASS1)--[study]--&amp;gt;(CLASS2)--[sleep]--&amp;gt;(SLEEP)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FACEBOOK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[facebook]--&amp;gt;(FACEBOOK)--[quit]--&amp;gt;(CLASS1)--[facebook]--&amp;gt;(FACEBOOK)--[quit]--&amp;gt;(CLASS1)--[study]--&amp;gt;(CLASS2)--[study]--&amp;gt;(CLASS3)--[pub]--&amp;gt;(CLASS2)--[study]--&amp;gt;(CLASS3)--[study]--&amp;gt;(SLEEP)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Rewards following a random policy&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Under this random policy, what total reward would the student expect when starting from any of the states?  We can estimate the expected rewards by summing up the rewards per trajectory and plotting the distributions of total rewards per starting&amp;nbsp;state:&lt;/p&gt;
&lt;p&gt;&lt;img alt="histogram of sampled returns" src="https://efavdb.com/images/intro_rl_histogram_sampled_returns.png"&gt;&lt;/p&gt;
&lt;h2&gt;Maximizing rewards: discounted return and value&amp;nbsp;functions&lt;/h2&gt;
&lt;p&gt;We’ve just seen how we can estimate rewards starting from each state given a random policy.  Next, we’ll formalize our goal in terms of maximizing&amp;nbsp;returns.&lt;/p&gt;
&lt;h3&gt;Returns&lt;/h3&gt;
&lt;p&gt;We simply summed the rewards from the sample trajectories above, but the quantity we often want to maximize in practice is the &lt;strong&gt;discounted return &lt;span class="math"&gt;\(G_t\)&lt;/span&gt;&lt;/strong&gt;, which is a sum of the weighted&amp;nbsp;rewards:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{return} \tag{1}
G_t := R_{t+1} + \gamma R_{t+2} + … = \sum_{k=0}^\infty \gamma^k R_{t+k+1}
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(0 \leq \gamma \leq 1\)&lt;/span&gt;.  &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt; is the &lt;em&gt;discount rate&lt;/em&gt; which characterizes how much we weight rewards now vs. later.  Discounting is mathematically useful for avoiding infinite returns in MDPs without a terminal state and allows us to account for uncertainty in the future when we don’t have a perfect model of the&amp;nbsp;environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The discount factor introduces a time scale since it says that we don&amp;#8217;t care about rewards that are far in the future.  The half-life (actually, the &lt;span class="math"&gt;\(1/e\)&lt;/span&gt; life) of a reward in units of time steps is &lt;span class="math"&gt;\(1/(1-\gamma)\)&lt;/span&gt;, which comes from a definition of &lt;span class="math"&gt;\(1/e\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;\begin{align}
\frac{1}{e} = \lim_{n \rightarrow \infty} \left(1 - \frac{1}{n} \right)^n
\end{align}&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\gamma = 0.99\)&lt;/span&gt; is often used in practice, which corresponds to a half-life of 100 timesteps since &lt;span class="math"&gt;\(0.99^{100} = (1 - 1/100)^{100} \approx 1/e\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;Value&amp;nbsp;functions&lt;/h3&gt;
&lt;p&gt;Earlier, we were able to estimate the expected undiscounted returns starting from each state by sampling from the &lt;span class="caps"&gt;MDP&lt;/span&gt; under a random policy.  Value functions formalize this notion of the &amp;#8220;goodness&amp;#8221; of being in a&amp;nbsp;state.&lt;/p&gt;
&lt;h4&gt;State value function &lt;span class="math"&gt;\(v\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;The &lt;strong&gt;state value function&lt;/strong&gt; &lt;span class="math"&gt;\(v_{\pi}(s)\)&lt;/span&gt; is the expected return when starting in state &lt;span class="math"&gt;\(s\)&lt;/span&gt;, following policy &lt;span class="math"&gt;\(\pi\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value} \tag{2}
v_{\pi}(s) = \mathbb{E}_{\pi}[G_t | S_t = s]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;The state value function can be written as a recursive relationship, the Bellman expectation equation, expressing the value of a state in terms of the values of its neighors by making use of the Markov&amp;nbsp;property.&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value-bellman} \tag{3}
v_{\pi}(s) &amp;amp;=&amp;amp; \mathbb{E}_{\pi}[G_t | S_t = s] \\
       &amp;amp;=&amp;amp; \mathbb{E}_{\pi}[R_{t+1} + \gamma G_{t+2} | S_t = s] \\
       &amp;amp;=&amp;amp; \sum_{a} \pi(a|s) \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_{\pi}(s’) ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;This equation expresses the value of a state as an average over the discounted value of its neighbor / successor states, plus the expected reward transitioning from &lt;span class="math"&gt;\(s\)&lt;/span&gt; to &lt;span class="math"&gt;\(s’\)&lt;/span&gt;, and &lt;span class="math"&gt;\(v_{\pi}\)&lt;/span&gt; is the unique&lt;a href="#unique"&gt;*&lt;/a&gt; solution.  The distribution of rewards depends on the student’s policy since her actions influence her future&amp;nbsp;rewards.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note on terminology&lt;/em&gt;:
Policy &lt;em&gt;evaluation&lt;/em&gt; uses the Bellman expectation equation to solve for the value function given a policy &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; and environment dynamics &lt;span class="math"&gt;\(p(s’, r | s, a)\)&lt;/span&gt;.  This is different from policy iteration and value iteration, which are concerned with finding an optimal&amp;nbsp;policy.&lt;/p&gt;
&lt;p&gt;We can solve the Bellman equation for the value function as an alternative to the sampling we did earlier for the student toy example.  Since the problem has a small number of states and actions, and we have full knowledge of the environment, an exact solution is feasible by directly solving the system of linear equations or iteratively using dynamic programming.  Here is the solution to (\ref{state-value-bellman}) for &lt;span class="math"&gt;\(v\)&lt;/span&gt; under a random policy in the student example (compare to the sample means in the histogram of&amp;nbsp;returns):&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP value function random policy" src="https://efavdb.com/images/student_mdp_values_random_policy.png"&gt;&lt;/p&gt;
&lt;p&gt;We can verify that the solution is self-consistent by spot checking the value of a state in terms of the values of its neighboring states according to the Bellman equation, e.g. the &lt;span class="caps"&gt;CLASS1&lt;/span&gt; state with &lt;span class="math"&gt;\(v_{\pi}(\text{CLASS1}) = -1.3\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
v_{\pi}(\text{CLASS1}) = 0.5 [-2 + 2.7] + 0.5 [-1 + -2.3] = -1.3
$$&lt;/div&gt;
&lt;h4&gt;Action value function &lt;span class="math"&gt;\(q\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Another value function is the action value function &lt;span class="math"&gt;\(q_{\pi}(s, a)\)&lt;/span&gt;, which is the expected return from a state &lt;span class="math"&gt;\(s\)&lt;/span&gt; if we follow a policy &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; after taking an action &lt;span class="math"&gt;\(a\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{action-value} \tag{4}
q_{\pi}(s, a) := \mathbb{E}_{\pi} [ G_t | S_t = s, A = a ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;We can also write &lt;span class="math"&gt;\(v\)&lt;/span&gt; and &lt;span class="math"&gt;\(q\)&lt;/span&gt; in terms of each other.  For example, the state value function can be viewed as an average over the action value functions for that state, weighted by the probability of taking each action, &lt;span class="math"&gt;\(\pi\)&lt;/span&gt;, from that&amp;nbsp;state:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value-one-step-backup} \tag{5}
v_{\pi}(s) = \sum_{a} \pi(a|s) q_{\pi}(s, a)
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;Rewriting &lt;span class="math"&gt;\(v\)&lt;/span&gt; in terms of &lt;span class="math"&gt;\(q\)&lt;/span&gt; in (\ref{state-value-one-step-backup}) is useful later for thinking about the &amp;#8220;advantage&amp;#8221;, &lt;span class="math"&gt;\(A(s,a)\)&lt;/span&gt;, of taking an action in a state, namely how much better is an action in that state than the&amp;nbsp;average?&lt;/p&gt;
&lt;div class="math"&gt;\begin{align}
A(s,a) \equiv q(s,a) - v(s)
\end{align}&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Why &lt;span class="math"&gt;\(q\)&lt;/span&gt; in addition to &lt;span class="math"&gt;\(v\)&lt;/span&gt;?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Looking ahead, we almost never have access to the environment dynamics in real world problems, but solving for &lt;span class="math"&gt;\(q\)&lt;/span&gt; instead of &lt;span class="math"&gt;\(v\)&lt;/span&gt; lets us get around this problem; we can figure out the best action to take in a state solely using &lt;span class="math"&gt;\(q\)&lt;/span&gt; (we further expand on this in our &lt;a href="#optimalq"&gt;discussion&lt;/a&gt; below on the Bellman optimality equation for &lt;span class="math"&gt;\(q_*\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;A concrete example of using &lt;span class="math"&gt;\(q\)&lt;/span&gt; is provided in our &lt;a href="https://efavdb.com/multiarmed-bandits"&gt;post&lt;/a&gt; on multiarmed bandits (an example of a simple single-state &lt;span class="caps"&gt;MDP&lt;/span&gt;), which discusses agents/algorithms that don&amp;#8217;t have access to the true environment dynamics.  The strategy amounts to estimating the action value function of the slot machine and using those estimates to inform which slot machine arms to pull in order to maximize&amp;nbsp;rewards.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Optimal value and&amp;nbsp;policy&lt;/h2&gt;
&lt;p&gt;The crux of the &lt;span class="caps"&gt;RL&lt;/span&gt; problem is finding a policy that maximizes the expected return.  A policy &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; is defined to be better than another policy &lt;span class="math"&gt;\(\pi’\)&lt;/span&gt; if &lt;span class="math"&gt;\(v_{\pi}(s) &amp;gt; v_{\pi’}(s)\)&lt;/span&gt; for all states.  We are guaranteed&lt;a href="#unique"&gt;*&lt;/a&gt; an optimal state value function &lt;span class="math"&gt;\(v_*\)&lt;/span&gt; which corresponds to one or more optimal policies &lt;span class="math"&gt;\(\pi*\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Recall that the value function for an arbitrary policy can be written in terms of an average over the action values for that state (\ref{state-value-one-step-backup}).  In contrast, the optimal value function &lt;span class="math"&gt;\(v_*\)&lt;/span&gt; must be consistent with following a policy that selects the action that maximizes the action value functions from a state, i.e. taking a &lt;span class="math"&gt;\(\max\)&lt;/span&gt; (\ref{state-value-bellman-optimality}) instead of an average (\ref{state-value-one-step-backup}) over &lt;span class="math"&gt;\(q\)&lt;/span&gt;, leading to the &lt;strong&gt;Bellman optimality equation&lt;/strong&gt; for &lt;span class="math"&gt;\(v_*\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{state-value-bellman-optimality} \tag{6}
v_*(s) &amp;amp;=&amp;amp; \max_a q_{\pi*}(s, a) \\
    &amp;amp;=&amp;amp; \max_a \mathbb{E}_{\pi*} [R_{t+1} + \gamma v_*(S_{t+1}) | S_t = s, A_t = a] \\
    &amp;amp;=&amp;amp; \max_a \sum_{s’, r} p(s’, r | s, a) [r + \gamma v_*(s’) ]
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;The optimal policy immediately follows: take the action in a state that maximizes the right hand side of (\ref{state-value-bellman-optimality}).  The &lt;a href="https://en.wikipedia.org/wiki/Bellman_equation#Bellman's_Principle_of_Optimality"&gt;principle of optimality&lt;/a&gt;, which applies to the Bellman optimality equation, means that this greedy policy actually corresponds to the optimal policy!  Note: Unlike the Bellman expectation equations, the Bellman optimality equations are a nonlinear system of equations due to taking the&amp;nbsp;max.&lt;/p&gt;
&lt;p&gt;The Bellman optimality equation for the action value function &lt;span class="math"&gt;\(q_*(s,a)\)&lt;/span&gt;&lt;a name="optimalq"&gt;&lt;/a&gt;&amp;nbsp;is:&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}\label{action-value-bellman-optimality} \tag{7}
q_*(s, a) &amp;amp;=&amp;amp; \mathbb{E}_{\pi*} [R_{t+1} + \gamma \max_{a'} q_*(S_{t+1}', a') | S_t = s, A_t = a] \\
          &amp;amp;=&amp;amp; \sum_{s', r} p(s', r | s, a) [r + \gamma \max_{a'} q_*(s', a') ]
\end{eqnarray}&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;Looking ahead: In practice, without a knowledge of the environment dynamics, &lt;span class="caps"&gt;RL&lt;/span&gt; algorithms based on solving value functions can approximate the expectation in (\ref{action-value-bellman-optimality}) by sampling, i.e. interacting with the environment, and iteratively selecting the action that corresponds to maximizing &lt;span class="math"&gt;\(q\)&lt;/span&gt; in each state that the agent lands in along its trajectory, which is possible since the maximum occurs &lt;strong&gt;inside&lt;/strong&gt; the summation in (\ref{action-value-bellman-optimality}).   In contrast, this sampling approach doesn&amp;#8217;t work for (\ref{state-value-bellman-optimality}) because of the maximum &lt;strong&gt;outside&lt;/strong&gt; the summation in&amp;#8230;that&amp;#8217;s why action value functions are so useful when we lack a model of the&amp;nbsp;environment!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Here is the optimal state value function and policy for the student example, which we solve for in a later&amp;nbsp;post:&lt;/p&gt;
&lt;p&gt;&lt;img alt="student MDP optimal value function" src="https://efavdb.com/images/student_mdp_optimal_values.png"&gt;&lt;/p&gt;
&lt;p&gt;Comparing the values per state under the optimal policy vs the random policy, the value in every state under the optimal policy exceeds the value under the random&amp;nbsp;policy.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;We’ve discussed how the problem of sequential decision making can be framed as an &lt;span class="caps"&gt;MDP&lt;/span&gt; using the student toy &lt;span class="caps"&gt;MDP&lt;/span&gt; as an example.  The goal in &lt;span class="caps"&gt;RL&lt;/span&gt; is to figure out a policy &amp;#8212; what actions to take in each state &amp;#8212; that maximizes our&amp;nbsp;returns.&lt;/p&gt;
&lt;p&gt;MDPs provide a framework for approaching the problem by defining the value of each state, the value functions, and using the value functions to define what a “best policy” means.  The value functions are unique solutions to the Bellman equations, and the &lt;span class="caps"&gt;MDP&lt;/span&gt; is “solved” when we know the optimal value&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;Much of reinforcement learning centers around trying to solve these equations under different conditions, e.g. unknown environment dynamics and large &amp;#8212; possibly continuous &amp;#8212; states and/or action spaces that require approximations to the value&amp;nbsp;functions.&lt;/p&gt;
&lt;p&gt;We&amp;#8217;ll discuss how we arrived at the solutions for this toy problem in a future&amp;nbsp;post!&lt;/p&gt;
&lt;h3&gt;Example&amp;nbsp;code&lt;/h3&gt;
&lt;p&gt;Code for sampling from the student environment under a random policy in order to generate the trajectories and histograms of returns is available in this &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP.ipynb"&gt;jupyter notebook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/discrete_limit_env.py"&gt;code&lt;/a&gt; for the student environment creates an environment with an &lt;span class="caps"&gt;API&lt;/span&gt; that is compatible with OpenAI gym &amp;#8212; specifically, it is derived from the &lt;code&gt;gym.envs.toy_text.DiscreteEnv&lt;/code&gt; environment.&lt;/p&gt;
&lt;p&gt;&lt;a name="unique"&gt;&lt;em&gt;&lt;/a&gt;The uniqueness of the solution to the Bellman equations for finite MDPs is stated without proof in Ref [2], but Ref [1] motivates it briefly via the &lt;/em&gt;contraction mapping&amp;nbsp;theorem*.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;[1] David Silver&amp;#8217;s &lt;span class="caps"&gt;RL&lt;/span&gt; Course Lecture 2 - (&lt;a href="https://www.youtube.com/watch?v=lfHX2hHRMVQ"&gt;video&lt;/a&gt;,
  &lt;a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching_files/MDP.pdf"&gt;slides&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;[2] Sutton and Barto -
  &lt;a href="http://incompleteideas.net/book/RLbook2018.pdf"&gt;Reinforcement Learning: An Introduction&lt;/a&gt; - Chapter 3: Finite Markov Decision&amp;nbsp;Processes&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Machine learning"></category><category term="reinforcement learning"></category><category term="machine learning"></category><category term="OpenAI"></category></entry><entry><title>Multiarmed bandits in the context of reinforcement learning</title><link href="https://efavdb.com/multiarmed-bandits" rel="alternate"></link><published>2020-02-25T00:00:00-08:00</published><updated>2020-02-25T00:00:00-08:00</updated><author><name>Cathy Yeh</name></author><id>tag:efavdb.com,2020-02-25:/multiarmed-bandits</id><summary type="html">&lt;p&gt;&lt;a href="http://incompleteideas.net/book/RLbook2018.pdf"&gt;Reinforcement Learning: An Introduction&lt;/a&gt; by Sutton and Barto[1] is a book that is universally recommended to beginners in their &lt;span class="caps"&gt;RL&lt;/span&gt; studies.  The first chapter is an extended text-heavy introduction. The second chapter deals with multiarmed bandits, i.e. slot machines with multiple arms, and is the subject of today …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://incompleteideas.net/book/RLbook2018.pdf"&gt;Reinforcement Learning: An Introduction&lt;/a&gt; by Sutton and Barto[1] is a book that is universally recommended to beginners in their &lt;span class="caps"&gt;RL&lt;/span&gt; studies.  The first chapter is an extended text-heavy introduction. The second chapter deals with multiarmed bandits, i.e. slot machines with multiple arms, and is the subject of today&amp;#8217;s&amp;nbsp;post.&lt;/p&gt;
&lt;p&gt;Before getting into the &lt;em&gt;what&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; of bandits, I&amp;#8217;d like to address the &lt;strong&gt;why&lt;/strong&gt;, since the &amp;#8220;why&amp;#8221; can guard against getting lost in the details / not seeing the forest for the&amp;nbsp;trees.&lt;/p&gt;
&lt;h1&gt;Why discuss multiarmed&amp;nbsp;bandits?&lt;/h1&gt;
&lt;p&gt;&lt;span class="caps"&gt;RL&lt;/span&gt; treats the problem of trying to achieve a goal in an environment where an agent is &lt;em&gt;not&lt;/em&gt; instructed about which actions to take to achieve that goal, in contrast to supervised learning problems.  Learning the best actions to take is a complicated problem, since the best actions depend on what state an agent is in, e.g. an agent trying to get to a goalpost east of its current location as quickly as possible may find that moving east is a generally good policy, but not if there is a fire-breathing dragon in the way, in which case, it might make sense to move up or down to navigate around the&amp;nbsp;obstacle.&lt;/p&gt;
&lt;p&gt;Multiarmed bandits are simpler problem: a single state system.  No matter which action an agent takes, i.e. which slot machine arm the agent pulls, the agent ends up back in the same state; the distribution of rewards as a consequence of the agent&amp;#8217;s action remains the same, assuming a stationary distribution of rewards, and actions have no effect on subsequent states or rewards.  This simple case study is useful for building intuition and introducing &lt;span class="caps"&gt;RL&lt;/span&gt; concepts that will be expanded on in later chapters of&amp;nbsp;[1].&lt;/p&gt;
&lt;h1&gt;Key &lt;span class="caps"&gt;RL&lt;/span&gt; concepts introduced by the multiarmed bandit&amp;nbsp;problem&lt;/h1&gt;
&lt;h2&gt;The nature of the&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Agent has a goal&lt;/strong&gt;: In &lt;span class="caps"&gt;RL&lt;/span&gt; and multiarmed bandit problems, we want to figure out the strategy, or &amp;#8220;policy&amp;#8221; in &lt;span class="caps"&gt;RL&lt;/span&gt; lingo, that will maximize our rewards.  For the simple bandit problem, this goal is equivalent to maximizing the reward &amp;#8212; literally, money! &amp;#8212; for each arm&amp;nbsp;pull.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unlike supervised learning, no ground truth is supplied&lt;/strong&gt;: Each slot has a different distribution of rewards, but the agent playing the machine does not know that distribution.  Instead, the agent has to try different actions and evaluate how good the actions are.  The goodness of an action is straightforwardly determined by its immediate reward in the bandit&amp;nbsp;case.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exploration vs. exploitation&lt;/strong&gt;:  Based on a few trials, one arm may appear to yield the highest rewards, but the agent may decide to try others occasionally to improve its estimates of the rewards, an example of balancing exploration and exploitation.  The various algorithms handle exploration vs. exploitation differently, but this example introduces one method that is simple but widely-used in practice: the epsilon-greedy algorithm, which takes greedy actions most of the time (exploits) but takes random actions (explores) a fraction epsilon of the&amp;nbsp;time.&lt;/p&gt;
&lt;h3&gt;Different approaches to learning a&amp;nbsp;policy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;model-free&lt;/strong&gt;:  All the strategies discussed in [1] for solving the bandit problem are &amp;#8220;model-free&amp;#8221; strategies.  In real world applications, a model of the world is rarely available, and the agent has to figure out how to act based on sampled experience, and the same applies to the bandit case; even though bandits are a simpler single state system (we don&amp;#8217;t have to model transitions from state to state), an agent still does not know the model that generates the probability of a reward &lt;span class="math"&gt;\(r\)&lt;/span&gt; given an action &lt;span class="math"&gt;\(a\)&lt;/span&gt;, &lt;span class="math"&gt;\(P(r|a)\)&lt;/span&gt; and has to figure that out from trial and&amp;nbsp;error.&lt;/p&gt;
&lt;p&gt;There &lt;em&gt;are&lt;/em&gt; model-based algorithms that attempt to model the environment&amp;#8217;s transition dynamics from data, but many popular algorithms today are model-free because of the difficulty of modeling those&amp;nbsp;dynamics.&lt;/p&gt;
&lt;h4&gt;Learning&amp;nbsp;action-values&lt;/h4&gt;
&lt;p&gt;The bandit problem introduces the idea of estimating the expected value associated with each action, namely the &lt;em&gt;action-value function&lt;/em&gt; in &lt;span class="caps"&gt;RL&lt;/span&gt; terms.  The concept is very intuitive &amp;#8212; as an agent pulls on different bandit arms, it will accumulate rewards associated with each arm.  A simple way to estimate the expected value per arm is just to average the rewards generated by pulling on each slot.  The policy that follows is then implicit, namely, take the action / pull on the arm with the highest estimated&amp;nbsp;action-value!&lt;/p&gt;
&lt;p&gt;Historically, &lt;span class="caps"&gt;RL&lt;/span&gt; formalism has dealt with estimating value functions and using them to figure out a policy, which includes the Q-Learning (&amp;#8220;Q&amp;#8221; stands for action-value!) approach we mentioned in our earlier &lt;a href="https://efavdb.com/openai-scholars-intro"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Learning policies&amp;nbsp;directly&lt;/h4&gt;
&lt;p&gt;[1] also use the bandit problem to introduce a type of algorithm that approaches the problem, not indirectly by learning a value function and deriving the policy from those value functions, but by parameterizing the policy directly and learning the parameters that optimize the rewards.  This class of algorithm is a &amp;#8220;policy gradient method&amp;#8221; and is very popular today for its nice convergence properties.  After the foreshadowing in the bandit problem, policy gradients only reappear very late in [1] &amp;#8212; chapter&amp;nbsp;13!&lt;/p&gt;
&lt;p&gt;We now provide code for&amp;nbsp;concreteness.&lt;/p&gt;
&lt;h1&gt;Ground truth is hidden in our multiarmed&amp;nbsp;bandit&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;Bandit&lt;/code&gt; class initializes a multiarmed bandit. The distribution of rewards per arm follows a Gaussian distribution with some mean dollar&amp;nbsp;amount.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Bandit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;N-armed bandit with stationary distribution of rewards per arm.&lt;/span&gt;
&lt;span class="sd"&gt;    Each arm (action) is identified by an integer.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_arms&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigma&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_arms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n_arms&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sigma&lt;/span&gt;
        &lt;span class="c1"&gt;# a dict of the mean action_value per arm, w/ each action_value sampled from a Gaussian&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;action_values&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigma&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_arms&lt;/span&gt;&lt;span class="p"&gt;))}&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;actions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;action_values&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  &lt;span class="c1"&gt;# arms of the bandit&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Get reward from bandit for action&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;action_values&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Implementation detail: the means per arm, stored in &lt;code&gt;self.action_values&lt;/code&gt;, are drawn from a Gaussian distribution upon&amp;nbsp;initialization).&lt;/p&gt;
&lt;p&gt;The agent doesn&amp;#8217;t know the true mean rewards per arm &amp;#8212; it only sees a sample reward when he takes the action of pulling on a particular bandit arm (&lt;code&gt;__call__&lt;/code&gt;).&lt;/p&gt;
&lt;h1&gt;Action, reward, update&amp;nbsp;strategy&lt;/h1&gt;
&lt;p&gt;For every action the agent takes, it gets a reward.  With each additional interaction with the bandit, the agent has a new data point it can use to update its strategy (whether indirectly, via an updated action-value estimate, or directly in the policy&amp;nbsp;gradient).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BaseBanditAlgo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ABC&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Base class for algorithms to maximize the rewards &lt;/span&gt;
&lt;span class="sd"&gt;    for the multiarmed bandit problem&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Bandit&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bandit&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timestep&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rewards&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="nd"&gt;@abstractmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_select_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="nd"&gt;@abstractmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_update_for_action_and_reward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
         &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_select_action&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;reward&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_update_for_action_and_reward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reward&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;reward&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_timesteps&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_timesteps&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timestep&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rewards&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Two types of strategies: value based and policy&amp;nbsp;based&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;value based - agents try to directly estimate the value of
   each action (and whose policies, i.e. probability of selecting an
   action, are therefore implicit, since the agent will want to choose
   the action that has the highest&amp;nbsp;value)&lt;/li&gt;
&lt;li&gt;policy based - agents don&amp;#8217;t try to directly estimate the value
   of an action and instead directly store the policy, i.e. the
   probability of taking each&amp;nbsp;action.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An example of a &lt;strong&gt;value based&lt;/strong&gt; strategy / action-value method for the
bandit problem is the &lt;code&gt;EpsilonGreedy&lt;/code&gt; approach, which selects the
action associated with the highest estimated action-value with probability &lt;span class="math"&gt;\(1-\epsilon\)&lt;/span&gt;, but chooses a random arm
a fraction &lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt; of the time as part of its exploration&amp;nbsp;strategy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EpsilonGreedy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BaseEstimateActionValueAlgo&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Greedy algorithm that explores/samples from the non-greedy action some fraction, &lt;/span&gt;
&lt;span class="sd"&gt;    epsilon, of the time.&lt;/span&gt;

&lt;span class="sd"&gt;    - For a basic greedy algorithm, set epsilon = 0.&lt;/span&gt;
&lt;span class="sd"&gt;    - For optimistic intialization, set q_init &amp;gt; mu, the mean of the Gaussian from&lt;/span&gt;
&lt;span class="sd"&gt;      which the real values per bandit arm are sampled (default is 0).&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Bandit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;epsilon&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;epsilon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;epsilon&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_select_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;epsilon&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# take random action&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# take greedy action&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;est_action_values&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;est_action_values&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(See end of post for additional action-value&amp;nbsp;methods.)&lt;/p&gt;
&lt;p&gt;An example of a &lt;strong&gt;policy based&lt;/strong&gt; strategy is the &lt;code&gt;GradientBandit&lt;/code&gt;
method, which stores its policy, the probability per action in
&lt;code&gt;self.preferences&lt;/code&gt;.  It learns these preferences by doing stochastic
gradient ascent along the preferences in the gradient of the expected
reward in &lt;code&gt;_update_for_action_and_reward&lt;/code&gt; (see [1] for&amp;nbsp;derivation).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GradientBandit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BaseBanditAlgo&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Algorithm that does not try to estimate action values directly and, instead, tries to learn&lt;/span&gt;
&lt;span class="sd"&gt;    a preference for each action (equivalent to stochastic gradient ascent along gradient in expected&lt;/span&gt;
&lt;span class="sd"&gt;    reward over preferences).&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Bandit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;  &lt;span class="c1"&gt;# step-size&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reward_baseline_avg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;preferences&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_calc_probs_from_preferences&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_calc_probs_from_preferences&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Probabilities per action follow a Boltzmann distribution over the preferences &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;exp_preferences_for_action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;preferences&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
        &lt;span class="n"&gt;partition_fxn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exp_preferences_for_action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;probabilities_for_action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OrderedDict&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;partition_fxn&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; 
                                                     &lt;span class="n"&gt;exp_preferences_for_action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()})&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_select_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;probabilities_for_action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; 
                                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;probabilities_for_action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_update_for_action_and_reward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reward&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Update preferences&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;reward_diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;reward&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reward_baseline_avg&lt;/span&gt;

        &lt;span class="c1"&gt;# can we combine these updates into single expression using kronecker delta?&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;preferences&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;reward_diff&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;probabilities_for_action&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bandit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;preferences&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;reward_diff&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;probabilities_for_action&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reward_baseline_avg&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timestep&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;reward_diff&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_calc_probs_from_preferences&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Extra: Total rewards for different bandit&amp;nbsp;algorithms&lt;/h1&gt;
&lt;p&gt;We have discussed a bunch of different bandit algorithms, but haven&amp;#8217;t seen what rewards they yield in&amp;nbsp;practice!&lt;/p&gt;
&lt;p&gt;In this
&lt;a href="https://github.com/frangipane/reinforcement-learning/blob/master/00-Introduction/multiarmed_bandits.ipynb"&gt;Jupyter notebook&lt;/a&gt;,
we run the algorithms through a range of values for their parameters
to compare their cumulative rewards across 1000 timesteps (also
averaged across many trials of different bandits to smooth things
out).  In the end, we arrive at a plot of the parameter study, that
reproduces Figure 2.6 in&amp;nbsp;[1].&lt;/p&gt;
&lt;p&gt;&lt;img alt="![parameter study]({static}/images/reproduce_multiarmed_bandit_parameter_study.png)" src="https://efavdb.com/images/reproduce_multiarmed_bandit_parameter_study.png"&gt;&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;p&gt;[1] Sutton and Barto - &lt;a href="http://incompleteideas.net/book/RLbook2018.pdf"&gt;Reinforcement Learning: An Introduction (2nd&amp;nbsp;Edition)&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Machine learning"></category><category term="reinforcement learning"></category><category term="machine learning"></category></entry></feed>